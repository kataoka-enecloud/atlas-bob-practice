// Code generated by BobGen psql v0.41.1. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"fmt"
	"io"

	"github.com/aarondl/opt/omit"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/sm"
	"github.com/stephenafamo/bob/dialect/psql/um"
	"github.com/stephenafamo/bob/expr"
	"github.com/stephenafamo/bob/mods"
	"github.com/stephenafamo/bob/orm"
	"github.com/stephenafamo/bob/types/pgtypes"
)

// GroupUser is an object representing the database table.
type GroupUser struct {
	GroupID int64 `db:"group_id" `
	UserID  int64 `db:"user_id" `

	R groupUserR `db:"-" `
}

// GroupUserSlice is an alias for a slice of pointers to GroupUser.
// This should almost always be used instead of []*GroupUser.
type GroupUserSlice []*GroupUser

// GroupUsers contains methods to work with the group_users view
var GroupUsers = psql.NewViewx[*GroupUser, GroupUserSlice]("", "group_users", buildGroupUserColumns("group_users"))

// GroupUsersQuery is a query on the group_users view
type GroupUsersQuery = *psql.ViewQuery[*GroupUser, GroupUserSlice]

// groupUserR is where relationships are stored.
type groupUserR struct {
	Group *Group // group_users.group_users_group_id_fkey
	User  *User  // group_users.group_users_user_id_fkey
}

func buildGroupUserColumns(alias string) groupUserColumns {
	return groupUserColumns{
		ColumnsExpr: expr.NewColumnsExpr(
			"group_id", "user_id",
		).WithParent("group_users"),
		tableAlias: alias,
		GroupID:    psql.Quote(alias, "group_id"),
		UserID:     psql.Quote(alias, "user_id"),
	}
}

type groupUserColumns struct {
	expr.ColumnsExpr
	tableAlias string
	GroupID    psql.Expression
	UserID     psql.Expression
}

func (c groupUserColumns) Alias() string {
	return c.tableAlias
}

func (groupUserColumns) AliasedAs(alias string) groupUserColumns {
	return buildGroupUserColumns(alias)
}

// GroupUserSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type GroupUserSetter struct {
	GroupID omit.Val[int64] `db:"group_id" `
	UserID  omit.Val[int64] `db:"user_id" `
}

func (s GroupUserSetter) SetColumns() []string {
	vals := make([]string, 0, 2)
	if s.GroupID.IsValue() {
		vals = append(vals, "group_id")
	}
	if s.UserID.IsValue() {
		vals = append(vals, "user_id")
	}
	return vals
}

func (s GroupUserSetter) Overwrite(t *GroupUser) {
	if s.GroupID.IsValue() {
		t.GroupID = s.GroupID.MustGet()
	}
	if s.UserID.IsValue() {
		t.UserID = s.UserID.MustGet()
	}
}

func (s *GroupUserSetter) Apply(q *dialect.InsertQuery) {
	q.AppendValues(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		vals := make([]bob.Expression, 2)
		if s.GroupID.IsValue() {
			vals[0] = psql.Arg(s.GroupID.MustGet())
		} else {
			vals[0] = psql.Raw("DEFAULT")
		}

		if s.UserID.IsValue() {
			vals[1] = psql.Arg(s.UserID.MustGet())
		} else {
			vals[1] = psql.Raw("DEFAULT")
		}

		return bob.ExpressSlice(ctx, w, d, start, vals, "", ", ", "")
	}))
}

func (s GroupUserSetter) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return um.Set(s.Expressions()...)
}

func (s GroupUserSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 2)

	if s.GroupID.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "group_id")...),
			psql.Arg(s.GroupID),
		}})
	}

	if s.UserID.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "user_id")...),
			psql.Arg(s.UserID),
		}})
	}

	return exprs
}

// AfterQueryHook is called after GroupUser is retrieved from the database
func (o *GroupUser) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = GroupUsers.AfterSelectHooks.RunHooks(ctx, exec, GroupUserSlice{o})
	}

	return err
}

// AfterQueryHook is called after GroupUserSlice is retrieved from the database
func (o GroupUserSlice) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = GroupUsers.AfterSelectHooks.RunHooks(ctx, exec, o)
	}

	return err
}

// Group starts a query for related objects on groups
func (o *GroupUser) Group(mods ...bob.Mod[*dialect.SelectQuery]) GroupsQuery {
	return Groups.Query(append(mods,
		sm.Where(Groups.Columns.ID.EQ(psql.Arg(o.GroupID))),
	)...)
}

func (os GroupUserSlice) Group(mods ...bob.Mod[*dialect.SelectQuery]) GroupsQuery {
	pkGroupID := make(pgtypes.Array[int64], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkGroupID = append(pkGroupID, o.GroupID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkGroupID), "bigint[]")),
	))

	return Groups.Query(append(mods,
		sm.Where(psql.Group(Groups.Columns.ID).OP("IN", PKArgExpr)),
	)...)
}

// User starts a query for related objects on users
func (o *GroupUser) User(mods ...bob.Mod[*dialect.SelectQuery]) UsersQuery {
	return Users.Query(append(mods,
		sm.Where(Users.Columns.ID.EQ(psql.Arg(o.UserID))),
	)...)
}

func (os GroupUserSlice) User(mods ...bob.Mod[*dialect.SelectQuery]) UsersQuery {
	pkUserID := make(pgtypes.Array[int64], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkUserID = append(pkUserID, o.UserID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkUserID), "bigint[]")),
	))

	return Users.Query(append(mods,
		sm.Where(psql.Group(Users.Columns.ID).OP("IN", PKArgExpr)),
	)...)
}

type groupUserWhere[Q psql.Filterable] struct {
	GroupID psql.WhereMod[Q, int64]
	UserID  psql.WhereMod[Q, int64]
}

func (groupUserWhere[Q]) AliasedAs(alias string) groupUserWhere[Q] {
	return buildGroupUserWhere[Q](buildGroupUserColumns(alias))
}

func buildGroupUserWhere[Q psql.Filterable](cols groupUserColumns) groupUserWhere[Q] {
	return groupUserWhere[Q]{
		GroupID: psql.Where[Q, int64](cols.GroupID),
		UserID:  psql.Where[Q, int64](cols.UserID),
	}
}

func (o *GroupUser) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "Group":
		rel, ok := retrieved.(*Group)
		if !ok {
			return fmt.Errorf("groupUser cannot load %T as %q", retrieved, name)
		}

		o.R.Group = rel

		if rel != nil {
			rel.R.GroupUsers = GroupUserSlice{o}
		}
		return nil
	case "User":
		rel, ok := retrieved.(*User)
		if !ok {
			return fmt.Errorf("groupUser cannot load %T as %q", retrieved, name)
		}

		o.R.User = rel

		if rel != nil {
			rel.R.GroupUsers = GroupUserSlice{o}
		}
		return nil
	default:
		return fmt.Errorf("groupUser has no relationship %q", name)
	}
}

type groupUserPreloader struct {
	Group func(...psql.PreloadOption) psql.Preloader
	User  func(...psql.PreloadOption) psql.Preloader
}

func buildGroupUserPreloader() groupUserPreloader {
	return groupUserPreloader{
		Group: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*Group, GroupSlice](psql.PreloadRel{
				Name: "Group",
				Sides: []psql.PreloadSide{
					{
						From:        GroupUsers,
						To:          Groups,
						FromColumns: []string{"group_id"},
						ToColumns:   []string{"id"},
					},
				},
			}, Groups.Columns.Names(), opts...)
		},
		User: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*User, UserSlice](psql.PreloadRel{
				Name: "User",
				Sides: []psql.PreloadSide{
					{
						From:        GroupUsers,
						To:          Users,
						FromColumns: []string{"user_id"},
						ToColumns:   []string{"id"},
					},
				},
			}, Users.Columns.Names(), opts...)
		},
	}
}

type groupUserThenLoader[Q orm.Loadable] struct {
	Group func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	User  func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
}

func buildGroupUserThenLoader[Q orm.Loadable]() groupUserThenLoader[Q] {
	type GroupLoadInterface interface {
		LoadGroup(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type UserLoadInterface interface {
		LoadUser(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}

	return groupUserThenLoader[Q]{
		Group: thenLoadBuilder[Q](
			"Group",
			func(ctx context.Context, exec bob.Executor, retrieved GroupLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadGroup(ctx, exec, mods...)
			},
		),
		User: thenLoadBuilder[Q](
			"User",
			func(ctx context.Context, exec bob.Executor, retrieved UserLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadUser(ctx, exec, mods...)
			},
		),
	}
}

// LoadGroup loads the groupUser's Group into the .R struct
func (o *GroupUser) LoadGroup(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Group = nil

	related, err := o.Group(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.GroupUsers = GroupUserSlice{o}

	o.R.Group = related
	return nil
}

// LoadGroup loads the groupUser's Group into the .R struct
func (os GroupUserSlice) LoadGroup(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	groups, err := os.Group(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range groups {

			if !(o.GroupID == rel.ID) {
				continue
			}

			rel.R.GroupUsers = append(rel.R.GroupUsers, o)

			o.R.Group = rel
			break
		}
	}

	return nil
}

// LoadUser loads the groupUser's User into the .R struct
func (o *GroupUser) LoadUser(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.User = nil

	related, err := o.User(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.GroupUsers = GroupUserSlice{o}

	o.R.User = related
	return nil
}

// LoadUser loads the groupUser's User into the .R struct
func (os GroupUserSlice) LoadUser(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	users, err := os.User(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range users {

			if !(o.UserID == rel.ID) {
				continue
			}

			rel.R.GroupUsers = append(rel.R.GroupUsers, o)

			o.R.User = rel
			break
		}
	}

	return nil
}

type groupUserJoins[Q dialect.Joinable] struct {
	typ   string
	Group modAs[Q, groupColumns]
	User  modAs[Q, userColumns]
}

func (j groupUserJoins[Q]) aliasedAs(alias string) groupUserJoins[Q] {
	return buildGroupUserJoins[Q](buildGroupUserColumns(alias), j.typ)
}

func buildGroupUserJoins[Q dialect.Joinable](cols groupUserColumns, typ string) groupUserJoins[Q] {
	return groupUserJoins[Q]{
		typ: typ,
		Group: modAs[Q, groupColumns]{
			c: Groups.Columns,
			f: func(to groupColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Groups.Name().As(to.Alias())).On(
						to.ID.EQ(cols.GroupID),
					))
				}

				return mods
			},
		},
		User: modAs[Q, userColumns]{
			c: Users.Columns,
			f: func(to userColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Users.Name().As(to.Alias())).On(
						to.ID.EQ(cols.UserID),
					))
				}

				return mods
			},
		},
	}
}
